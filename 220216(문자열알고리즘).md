220216

문자열(string)- 인덱스연산

문자의 표현 : 혼동을 피하기 위해 표준안을 만들었다.

아스키코드 미국에서 문자 인코딩 표준을 만들었다.

A는 65 a는 97

타 국가가 코드체계를 가지고 있지 않아서 정보를 잘못 해석 할 수 있는 문제를 해결하기 위해 다국어 처리를 위한 표준으로 유니코드를 만들었다.

유니코드도 다시 Character Set으로 분류된다. 적당한 외부 인코딩이 필요하게 되었다. 

```python
my_str[a:b:c]
[::-1] : 뒤에서출력하기
```



### 문자열의 분류

자바 C언어 등의 문자열 처리가 조금씩 다르다.

Null 문자 : 숫자로 표현될때는 0으로 바뀌는 코드

None은 정의되지 않았다.

```python
s1 ='abc'
s5 = s1[:2] +'c'
print(s1==s5) #하면 True
print(s1 is s5) #하면 False나온다 왜냐하면 s5는 위치참조를 비교
```

ppt 36 패턴매칭 (해보기)



```python
str()함수 사용하지 않고, itoa()구현하기
아스키코드사용

Brute Force는 고지식한 알고리즘으로 오래걸린다
KMP알고리즘이 등장한다.
```

KMP알고리즘 :  39페이지 

불일치가 나면 불일치 난 부분에서 다시 시작하기

```python
i+=1, j+=1 일치하면 계속 진행하다가 불일치 발생하는 지점확인 해서 i는 그대로이고, j=next[j](불일치가 나타난 인덱스)
```

KMP알고리즘(코드)

skip배열이 어떻게 만들어지는지 만든 skip배열을 어떻게 쓰는지 챙기자

```python
def kmp(t, p):
    N = len(t)
    M = len(p)
    lps = [0] * (M+1)
    #preprocessing
    j = 0 #일치한 개수 == 비교할 패턴 위치
    lps[0] = -1
    for i in range(1, M):
        lps[i] = j #p[i] 이전에 일치한 개수
        if p[i] == p[j]:
            j += 1
		else:
            j = 0
	lps[m] = j
	i=0
	j=0
    while i < N and j <= M:
        if j == -1 or t[i] == p[j]: #첫글자 불일치하거나 일치하면
            i += 1
            j += 1
        else: #불일치
            j = lps[j]
        if j==m: #패턴을 찾을 경우
            print(i-M, end = ' ')
            j =lps[j] #다음패턴 찾을때 어디서부터시작
```

보이어-무어 알고리즘

첫글자가 같으면 바로 맨뒤에 글자 확인해서 뒤에서부터 하나씩 첫글자로 오면서 확인하는 알고리즘



### 문자열 암호화

시저 암호(Caesar cipher)

1개수찾기 문제 (영상 찍음)

### exlusive or

0이면 그대로 보여줌.

1이면 바꿔서 보여줌.



